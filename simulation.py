import random
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
import numpy as np
import pandas as pd
from prod.validator import Validator
from prod.coprocessor import Coprocessor
from prod.task import Task


class Simulation:
    def __init__(self, config):
        """
        Initialize the Simulation with a given configuration.

        Parameters:
        config (Config): Configuration object containing simulation parameters.
        """
        self.validators = [Validator(i, random.uniform(50, 120), random.uniform(0.8, 1.0), random.uniform(5, 20)) for i in range(config.num_validators)]
        self.coprocessors = [Coprocessor(i, random.uniform(100, 200), random.uniform(0.4, 1.0)) for i in range(config.num_coprocessors)]
        self.num_periods = config.num_periods
        self.validator_data = []
        self.coprocessor_data = []
        self.task_data = []
        self.config = config


    def run(self):
        """
        Run the simulation based on the provided configuration.
        """

        for period in range(self.num_periods):
            
            for cp in self.coprocessors:
                cp.reset_resources()
            for val in self.validators:
                val.reset_resources()

            tasks = [Task(i, random.uniform(1, 50), random.uniform(5, 20), random.uniform(0.1, 1.0), random.uniform(0.001, random.uniform(0.09,0.23))) for i in range(config.num_tasks)]
            for task in tasks:
                selected_validator = random.choice(self.validators)
                selected_validator.decide_and_assign_task(task, self.coprocessors)
                self.log_data(period, task, selected_validator)

    def log_data(self, period, task, validator):
        coprocessor = None
        if task.delegated_to is not None:
            coprocessor = next((cp for cp in self.coprocessors if cp.id == task.delegated_to), None)

        
        if coprocessor:
            self.coprocessor_data.append({
                'period': period,
                'coprocessor_id': coprocessor.id,
                'validator_id': validator.id,
                'load': coprocessor.resources,
                'reputation': coprocessor.reputation,
                'task_id': task.id,
                'task_difficulty': task.difficulty,
                'task_reward': task.reward,
                'coprocessor_reward': coprocessor.total_reward,  
                'slashing': task.compute_slashing(task.completed, period),
                'risk_factor': task.risk_factor,
                'delegated': 'Yes',
                'completed': task.completed
            })

        
        self.validator_data.append({
            'period': period,
            'validator_id': validator.id,
            'task_id': task.id,
            'task_difficulty': task.difficulty,
            'task_reward': task.reward,
            'delegated': 'Yes' if task.delegated_to is not None else 'No',
            'completed': task.completed,
            'reward': validator.calculate_rewards(period),
            'slashing': task.compute_slashing(task.completed, period),
            'risk_factor': task.risk_factor,
            'reputation': validator.reputation,
            'load': validator.resources
        })

        
        self.task_data.append({
            'period': period,
            'task_id': task.id,
            'difficulty': task.difficulty,
            'reward': task.reward,
            'completed': task.completed,
            'risk_factor': task.risk_factor,
            'slashing': task.compute_slashing(task.completed, period),
            'validator_id': validator.id,
            'coprocessor_id': task.delegated_to if task.delegated_to is not None else 'N/A'
        })

    def export_data(self):
        """
        Export data generated by the simulation.

        Returns:
        tuple: Contains validator_data, coprocessor_data, and task_data.
        """
        return pd.DataFrame(self.validator_data), pd.DataFrame(self.coprocessor_data), pd.DataFrame(self.task_data)